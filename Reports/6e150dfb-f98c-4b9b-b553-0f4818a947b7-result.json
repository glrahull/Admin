{"name": "test_validatelogin[data0]", "status": "broken", "statusDetails": {"message": "configparser.ParsingError: Source contains parsing errors: './ConfigurationFiles/Elements.cfg'\n\t[line  6]: '<<<<<<< HEAD\\n'", "trace": "data = ('nemagoswami00@gmail.com', 'IErk!@#$@123IENYMJAGA')\n\n    @pytest.mark.parametrize('data', DataGen.dataGenerator())\n    \n    def test_validatelogin(data):\n        driver = InitiateDriver.startBrowser()\n    \n        login = LoginPage.LoginClass(driver)\n>       login.enter_username(data[0])\n\nTestCases\\test_case_01.py:37: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nDecorators\\Slow.py:10: in wrapper\n    return func(*args, **kwargs)\nPages\\LoginPage.py:21: in enter_username\n    driver.find_element(by=By.NAME,value=ConfigReader.fetchelementLocators(\"Login\", \"username_name\")).send_keys(username)\nLibrary\\ConfigReader.py:15: in fetchelementLocators\n    config.read(\"./ConfigurationFiles/Elements.cfg\")\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\configparser.py:684: in read\n    self._read(fp, filename)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x00000237C54171D0>, fp = <_io.TextIOWrapper name='./ConfigurationFiles/Elements.cfg' mode='r' encoding='cp1252'>\nfpname = './ConfigurationFiles/Elements.cfg'\n\n    def _read(self, fp, fpname):\n        \"\"\"Parse a sectioned configuration file.\n    \n        Each section in a configuration file contains a header, indicated by\n        a name in square brackets (`[]`), plus key/value options, indicated by\n        `name` and `value` delimited with a specific substring (`=` or `:` by\n        default).\n    \n        Values can span multiple lines, as long as they are indented deeper\n        than the first line of the value. Depending on the parser's mode, blank\n        lines may be treated as parts of multiline values or ignored.\n    \n        Configuration files may include comments, prefixed by specific\n        characters (`#` and `;` by default). Comments may appear on their own\n        in an otherwise empty line or may be entered in lines holding values or\n        section names. Please note that comments get stripped off when reading configuration files.\n        \"\"\"\n        elements_added = set()\n        cursect = None                        # None, or a dictionary\n        sectname = None\n        optname = None\n        lineno = 0\n        indent_level = 0\n        e = None                              # None, or an exception\n        try:\n            for lineno, line in enumerate(fp, start=1):\n                comment_start = sys.maxsize\n                # strip inline comments\n                inline_prefixes = {p: -1 for p in self._inline_comment_prefixes}\n                while comment_start == sys.maxsize and inline_prefixes:\n                    next_prefixes = {}\n                    for prefix, index in inline_prefixes.items():\n                        index = line.find(prefix, index+1)\n                        if index == -1:\n                            continue\n                        next_prefixes[prefix] = index\n                        if index == 0 or (index > 0 and line[index-1].isspace()):\n                            comment_start = min(comment_start, index)\n                    inline_prefixes = next_prefixes\n                # strip full line comments\n                for prefix in self._comment_prefixes:\n                    if line.strip().startswith(prefix):\n                        comment_start = 0\n                        break\n                if comment_start == sys.maxsize:\n                    comment_start = None\n                value = line[:comment_start].strip()\n                if not value:\n                    if self._empty_lines_in_values:\n                        # add empty line to the value, but only if there was no\n                        # comment on the line\n                        if (comment_start is None and\n                            cursect is not None and\n                            optname and\n                            cursect[optname] is not None):\n                            cursect[optname].append('') # newlines added at join\n                    else:\n                        # empty line marks end of value\n                        indent_level = sys.maxsize\n                    continue\n                # continuation line?\n                first_nonspace = self.NONSPACECRE.search(line)\n                cur_indent_level = first_nonspace.start() if first_nonspace else 0\n                if (cursect is not None and optname and\n                    cur_indent_level > indent_level):\n                    cursect[optname].append(value)\n                # a section header or option header?\n                else:\n                    indent_level = cur_indent_level\n                    # is it a section header?\n                    mo = self.SECTCRE.match(value)\n                    if mo:\n                        sectname = mo.group('header')\n                        if sectname in self._sections:\n                            if self._strict and sectname in elements_added:\n                                raise DuplicateSectionError(sectname, fpname,\n                                                            lineno)\n                            cursect = self._sections[sectname]\n                            elements_added.add(sectname)\n                        elif sectname == self.default_section:\n                            cursect = self._defaults\n                        else:\n                            cursect = self._dict()\n                            self._sections[sectname] = cursect\n                            self._proxies[sectname] = SectionProxy(self, sectname)\n                            elements_added.add(sectname)\n                        # So sections can't start with a continuation line\n                        optname = None\n                    # no section header in the file?\n                    elif cursect is None:\n                        raise MissingSectionHeaderError(fpname, lineno, line)\n                    # an option line?\n                    else:\n                        mo = self._optcre.match(value)\n                        if mo:\n                            optname, vi, optval = mo.group('option', 'vi', 'value')\n                            if not optname:\n                                e = self._handle_error(e, fpname, lineno, line)\n                            optname = self.optionxform(optname.rstrip())\n                            if (self._strict and\n                                (sectname, optname) in elements_added):\n                                raise DuplicateOptionError(sectname, optname,\n                                                           fpname, lineno)\n                            elements_added.add((sectname, optname))\n                            # This check is fine because the OPTCRE cannot\n                            # match if it would set optval to None\n                            if optval is not None:\n                                optval = optval.strip()\n                                cursect[optname] = [optval]\n                            else:\n                                # valueless option handling\n                                cursect[optname] = None\n                        else:\n                            # a non-fatal parsing error occurred. set up the\n                            # exception but keep going. the exception will be\n                            # raised at the end of the file and will contain a\n                            # list of all bogus lines\n                            e = self._handle_error(e, fpname, lineno, line)\n        finally:\n            self._join_multiline_values()\n        # if any parsing errors occurred, raise an exception\n        if e:\n>           raise e\nE           configparser.ParsingError: Source contains parsing errors: './ConfigurationFiles/Elements.cfg'\nE           \t[line  6]: '<<<<<<< HEAD\\n'\n\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\configparser.py:1096: ParsingError"}, "parameters": [{"name": "data", "value": "('nemagoswami00@gmail.com', 'IErk!@#$@123IENYMJAGA')"}], "start": 1745836633462, "stop": 1745836642147, "uuid": "4d75aae8-d0a9-4a15-bbe2-d9086a1ad0ad", "historyId": "92c6ba6a0c9b1ee5c7f9cb1a1196e7a2", "testCaseId": "ea296bd1ea91bea02133093437afba3c", "fullName": "TestCases.test_case_01#test_validatelogin", "labels": [{"name": "parentSuite", "value": "TestCases"}, {"name": "suite", "value": "test_case_01"}, {"name": "host", "value": "EIB-THN-ITS-1059"}, {"name": "thread", "value": "21508-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "TestCases.test_case_01"}]}