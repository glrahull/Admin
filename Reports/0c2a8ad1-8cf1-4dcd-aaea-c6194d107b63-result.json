{"name": "test_validatelogin[data0]", "status": "broken", "statusDetails": {"message": "configparser.DuplicateOptionError: While reading from './ConfigurationFiles/Config.cfg' [line  5]: option 'application_url' in section 'Details' already exists", "trace": "data = ('nemagoswami00@gmail.com', 'IErk!@#$@123IENYMJAGA')\n\n    @pytest.mark.parametrize('data', DataGen.dataGenerator())\n    \n    def test_validatelogin(data):\n>       driver = InitiateDriver.startBrowser()\n\nTestCases\\test_case_01.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nBase\\InitiateDriver.py:10: in startBrowser\n    if ((ConfigReader.readConfigData('Details', 'Browser')) == 'chrome'):\nLibrary\\ConfigReader.py:7: in readConfigData\n    config.read(\"./ConfigurationFiles/Config.cfg\")\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\configparser.py:684: in read\n    self._read(fp, filename)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <configparser.ConfigParser object at 0x000001D70D56CC20>, fp = <_io.TextIOWrapper name='./ConfigurationFiles/Config.cfg' mode='r' encoding='cp1252'>\nfpname = './ConfigurationFiles/Config.cfg'\n\n    def _read(self, fp, fpname):\n        \"\"\"Parse a sectioned configuration file.\n    \n        Each section in a configuration file contains a header, indicated by\n        a name in square brackets (`[]`), plus key/value options, indicated by\n        `name` and `value` delimited with a specific substring (`=` or `:` by\n        default).\n    \n        Values can span multiple lines, as long as they are indented deeper\n        than the first line of the value. Depending on the parser's mode, blank\n        lines may be treated as parts of multiline values or ignored.\n    \n        Configuration files may include comments, prefixed by specific\n        characters (`#` and `;` by default). Comments may appear on their own\n        in an otherwise empty line or may be entered in lines holding values or\n        section names. Please note that comments get stripped off when reading configuration files.\n        \"\"\"\n        elements_added = set()\n        cursect = None                        # None, or a dictionary\n        sectname = None\n        optname = None\n        lineno = 0\n        indent_level = 0\n        e = None                              # None, or an exception\n        try:\n            for lineno, line in enumerate(fp, start=1):\n                comment_start = sys.maxsize\n                # strip inline comments\n                inline_prefixes = {p: -1 for p in self._inline_comment_prefixes}\n                while comment_start == sys.maxsize and inline_prefixes:\n                    next_prefixes = {}\n                    for prefix, index in inline_prefixes.items():\n                        index = line.find(prefix, index+1)\n                        if index == -1:\n                            continue\n                        next_prefixes[prefix] = index\n                        if index == 0 or (index > 0 and line[index-1].isspace()):\n                            comment_start = min(comment_start, index)\n                    inline_prefixes = next_prefixes\n                # strip full line comments\n                for prefix in self._comment_prefixes:\n                    if line.strip().startswith(prefix):\n                        comment_start = 0\n                        break\n                if comment_start == sys.maxsize:\n                    comment_start = None\n                value = line[:comment_start].strip()\n                if not value:\n                    if self._empty_lines_in_values:\n                        # add empty line to the value, but only if there was no\n                        # comment on the line\n                        if (comment_start is None and\n                            cursect is not None and\n                            optname and\n                            cursect[optname] is not None):\n                            cursect[optname].append('') # newlines added at join\n                    else:\n                        # empty line marks end of value\n                        indent_level = sys.maxsize\n                    continue\n                # continuation line?\n                first_nonspace = self.NONSPACECRE.search(line)\n                cur_indent_level = first_nonspace.start() if first_nonspace else 0\n                if (cursect is not None and optname and\n                    cur_indent_level > indent_level):\n                    cursect[optname].append(value)\n                # a section header or option header?\n                else:\n                    indent_level = cur_indent_level\n                    # is it a section header?\n                    mo = self.SECTCRE.match(value)\n                    if mo:\n                        sectname = mo.group('header')\n                        if sectname in self._sections:\n                            if self._strict and sectname in elements_added:\n                                raise DuplicateSectionError(sectname, fpname,\n                                                            lineno)\n                            cursect = self._sections[sectname]\n                            elements_added.add(sectname)\n                        elif sectname == self.default_section:\n                            cursect = self._defaults\n                        else:\n                            cursect = self._dict()\n                            self._sections[sectname] = cursect\n                            self._proxies[sectname] = SectionProxy(self, sectname)\n                            elements_added.add(sectname)\n                        # So sections can't start with a continuation line\n                        optname = None\n                    # no section header in the file?\n                    elif cursect is None:\n                        raise MissingSectionHeaderError(fpname, lineno, line)\n                    # an option line?\n                    else:\n                        mo = self._optcre.match(value)\n                        if mo:\n                            optname, vi, optval = mo.group('option', 'vi', 'value')\n                            if not optname:\n                                e = self._handle_error(e, fpname, lineno, line)\n                            optname = self.optionxform(optname.rstrip())\n                            if (self._strict and\n                                (sectname, optname) in elements_added):\n>                               raise DuplicateOptionError(sectname, optname,\n                                                           fpname, lineno)\nE                                                          configparser.DuplicateOptionError: While reading from './ConfigurationFiles/Config.cfg' [line  5]: option 'application_url' in section 'Details' already exists\n\n..\\..\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\configparser.py:1075: DuplicateOptionError"}, "parameters": [{"name": "data", "value": "('nemagoswami00@gmail.com', 'IErk!@#$@123IENYMJAGA')"}], "start": 1745836608001, "stop": 1745836608001, "uuid": "58314149-5184-495f-971a-d1aa2d538fef", "historyId": "92c6ba6a0c9b1ee5c7f9cb1a1196e7a2", "testCaseId": "ea296bd1ea91bea02133093437afba3c", "fullName": "TestCases.test_case_01#test_validatelogin", "labels": [{"name": "parentSuite", "value": "TestCases"}, {"name": "suite", "value": "test_case_01"}, {"name": "host", "value": "EIB-THN-ITS-1059"}, {"name": "thread", "value": "4604-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "TestCases.test_case_01"}]}